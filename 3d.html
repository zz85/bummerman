<!DOCTYPE html>
<html>

<head>
	<meta charset=utf-8>
	<title>3D Scene Tests</title>
	<style>
		body {
			margin: 0;
		}
		
		canvas {
			width: 100%;
			height: 100%
		}
	</style>
</head>

<body>
	<script src="https://threejs.org/build/three.js"></script>
	<script>
		var scene = new THREE.Scene();
		var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

		var geometry = new THREE.BoxBufferGeometry( 10, 10, 10 );
		var material = new THREE.MeshBasicMaterial( { color: 0xffffff } );
		var cube = new THREE.Mesh( geometry, material );
		var boxHelper = new THREE.BoxHelper( cube )

		const UNITS = 10;

		var pointLight = new THREE.PointLight( 0xffffff );

		const platform = new THREE.Object3D();

		scene.add(platform);

		boxHelper.position.y = UNITS / 2;
		platform.add(boxHelper);

		// var dlight = new THREE.DirectionalLight();

		scene.add(pointLight);


		// Soft Wall
		wallGeometry = new THREE.BoxBufferGeometry( 8, 8, 8 );
		wallMaterial = new THREE.MeshToonMaterial( {
			color: new THREE.Color().setRGB(0.98, 0.45, 1),
			specular: new THREE.Color().setRGB(1, 1, 1),
			shininess: 0.5,
			reflectivity: 0.5,
			shading: THREE.SmoothShading,
		} );

		wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
		wallMesh.position.y = UNITS / 2;
		// platform.add(wallMesh);

		// Floor

		floorGeometry = new THREE.PlaneBufferGeometry(UNITS * 2, UNITS * 2, 1, 1);

		floorMesh = new THREE.Mesh(floorGeometry, wallMaterial);
		floorMesh.rotation.x = -Math.PI / 2;
		platform.add(floorMesh);

		// Hard Wall
		wallGeometry = new THREE.BoxBufferGeometry( 8, 8, 8 );
		hardwallMaterial = new THREE.MeshToonMaterial( {
			color: new THREE.Color().setRGB(0.15, 0.15, .15),
			specular: new THREE.Color().setRGB(1, 1, 1),
			shininess: 0.0,
			reflectivity: 0.0
		} );

		hardWall = new THREE.Mesh(wallGeometry, hardwallMaterial);
		hardWall.position.y = UNITS / 2;
		// platform.add(hardWall);

		bomb = new THREE.Object3D();
		bombMaterial = new THREE.MeshToonMaterial( {
			color: new THREE.Color().setRGB(0.15, 0.15, .15),
			specular: new THREE.Color().setRGB(1, 1, 1),
			shininess: 0.0,
			reflectivity: 0.0,
			// wireframe: true
		} );

		sphereGeometry = new THREE.SphereBufferGeometry(5.2, 12, 12);
		ball = new THREE.Mesh(sphereGeometry, bombMaterial);
		bomb.add(ball);

		capGeometry = new THREE.CylinderBufferGeometry( 2.5, 2.5, 1, 12 );
		cap = new THREE.Mesh(capGeometry, bombMaterial);
		cap.position.y = 5;
		bomb.add(cap);


		var Path = THREE.Curve.create(
			function () { //custom curve constructor
			},

			function ( t ) { //getPoint: t is between 0-1
				var tx = t; // Math.cos( t ) * 2 * 
				var ty = t * 3.5;
				var tz = Math.sin( t ) * 2 * t;

				return new THREE.Vector3( tx, ty, tz );
			}
		);

		var path = new Path();

		fuseGeometry = new THREE.TubeBufferGeometry( path, 20, 0.4, 8, false );
		fuse = new THREE.Mesh(fuseGeometry, bombMaterial);
		fuse.position.y = 5

		bomb.add(fuse);
		
		bomb.position.y = UNITS / 2;
		// platform.add(bomb);

		man = new THREE.Object3D();

		headMaterial = new THREE.MeshToonMaterial( {
			color: new THREE.Color().setRGB(0.35, 0.15, .95),
			specular: new THREE.Color().setRGB(1, 1, 1),
			shininess: 0.0,
			reflectivity: 0.0,
			// wireframe: true
		} );
		
		var roundedRectShape = new THREE.Shape();
		( function roundedRect( ctx, x, y, width, height, radius ){

			ctx.moveTo( x, y + radius );
			ctx.lineTo( x, y + height - radius );
			ctx.quadraticCurveTo( x, y + height, x + radius, y + height );
			ctx.lineTo( x + width - radius, y + height) ;
			ctx.quadraticCurveTo( x + width, y + height, x + width, y + height - radius );
			ctx.lineTo( x + width, y + radius );
			ctx.quadraticCurveTo( x + width, y, x + width - radius, y );
			ctx.lineTo( x + radius, y );
			ctx.quadraticCurveTo( x, y, x, y + radius );

		} )( roundedRectShape, -1, -1, 2, 2, 1 );

		var extrudeSettings = { amount: .6, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: .2, bevelThickness: .2 }
		var headGeometry = new THREE.ExtrudeGeometry( roundedRectShape, extrudeSettings );

		head = new THREE.Mesh(headGeometry, headMaterial);

		tailGeometry = new THREE.SphereBufferGeometry(0.4, 8, 8);
		tail = new THREE.Mesh(tailGeometry, headMaterial);
		tail.position.y = 1;
		tail.position.z = -0.6;
		head.add(tail);

		var faceGeometry = new THREE.CircleBufferGeometry( 3, 12 );

		head.position.z = -0.2;
		head.position.y = 1.9;
		head.scale.y = 0.8;
		face = new THREE.Mesh(faceGeometry, headMaterial);
		face.rotation.y = Math.PI;
		// head.add(face);
		man.add(head);
		man.position.y = UNITS / 2;

		// Egg formula from http://www.mathematische-basteleien.de/eggcurves.htm
		// x^2 + (1.4 ^ x * 1.6 * y)^2 = 1;
		// (1.4 ^ x * 1.6 * y)^2 = 1 - x^2;
		// 1.4 ^ x * 1.6 * y = Math.pow(1 - x^2, 0.5);
		// y = Math.pow(1 - x^2, 0.5) / (1.4 ^ x * 1.6)

		eggFormula = x => Math.pow(1 - x ** 2, 0.5) / (1.4 ** x * 1.6)

		const divisions = 15;
		const spline = [];
		for (let x = 0; x <= divisions; x++) {
			const t = (x / divisions - 0.5) * 2;
			spline.push(new THREE.Vector2(eggFormula(t), t));
		}

		bodyGeometry = new THREE.LatheBufferGeometry( spline );
		var material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
		var body = new THREE.Mesh( bodyGeometry, headMaterial );

		var armGeometry = new THREE.CylinderBufferGeometry( .1, .14, 1.5, 8 );
		arm = new THREE.Mesh(armGeometry, headMaterial);
		arm.position.y = 0.5;
		// arm.position.x = 1;
		arm.rotation.z = Math.PI / 2;

		man.add(arm);

		man.add(body);
		man.scale.multiplyScalar(2); 
		platform.add(man);

		camera.position.x = 10;
		camera.position.y = UNITS * 1.2;
		camera.position.z = 15;
		pointLight.position.set(15, 5, 15);

		var renderer = new THREE.WebGLRenderer();
		renderer.setSize( window.innerWidth, window.innerHeight );
		document.body.appendChild( renderer.domElement );

		animate();

		function animate() {
			requestAnimationFrame(animate);

			render();
		}

		function render() {
			platform.rotation.y += 0.01;

			n = Date.now() / 1000 * 4;
			head.rotation.y = Math.sin(n) * 0.4;

			camera.lookAt(scene.position);
			renderer.render(scene, camera);
		}

		</script>
</body>

</html>